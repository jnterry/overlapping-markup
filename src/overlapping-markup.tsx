import React from 'react';

/**
 * React component type for rendering individual text segments
 *
 * @param props - Props for the text segment
 * @param props.children - The text to render
 * @param props.text - The full text being rendered by the parent OverlappingMarkup component
 * @param props.min - The first character index of the text to render
 * @param props.max - The last character index of the text to render
 */
export type TextWrapperComponent = React.ComponentType<{
	children: string;
	text: string;
	min: number;
	max: number;
}>;

/**
 * Props for the before/content/after rendering components
 */
export interface ContentRendererProps<TStyleData = any, TState extends Record<string, any> = Record<string, any>> {
	/**
	 * Styling data for this block as taken from the styling array passed to the OverlappingMarkup component
	 */
	styleData: TStyleData;

	/**
	 * Auto-managed state for this block
	 */
	state: TState;

	/**
	 * Function to update the auto-managed state for this block
	 */
	setState: React.Dispatch<React.SetStateAction<TState>>;

	/**
	 * Content to render within this block. For a before/after block this will be empty! For
	 * a content block it may be a mixture of text and/or other nested content renderers
	 */
	children?: React.ReactElement
}

/**
 * Type for a content renderer component
 */
export type ContentRenderer<
	TStyleData = any,
	TState extends Record<string, any> = Record<string, any>
> = React.ComponentType<ContentRendererProps<TStyleData, TState>>;

/**
 * Definition of the styling to use for a block including content renderers and any initial
 * auto-managed state which then gets passed through to the content renderers
 *
 * These are intended to be reusable specifications that can be referenced by multiple `StylingBlocks`
 * in the renderer's `styling` array
 */
export interface StyleDef<
	TStyleData = any,
	TState extends Record<string, any> = Record<string, any>
> {
	/** Optional component to render before the first text segment of this block */
	before?: ContentRenderer<TStyleData, TState>;

	/** Component to render each text segment of this block */
	content: ContentRenderer<TStyleData, TState>;

	/** Optional component to render after the final text segment of this block */
	after?: ContentRenderer<TStyleData, TState>;

	/** Initial state for this block on first render */
	initialState?: TState;
}

/**
 * Represents a single range of text with associated styling
 */
export interface StylingBlock<
	TStyleData = any,
	TState extends Record<string, any> = Record<string, any>
> {
	id?: string | number;

	/** First character index of the text segment to be rendered */
	min: number;

	/** Last character index of the text segment to be rendered */
	max: number;

	/**
	 * Data associated with this block, passed through the the renderering components as styleData prop
	 */
	data?: TStyleData;

	/**
	 * Styling definition to use for this block
	 */
	style: StyleDef<TStyleData, TState>;
}

/**
 * Function called to break ties when sorting the styling elements into order. This can matter
 * when multiple blocks have the same `min` and/or `max` values, since the order of the before/after
 * content will depend on how such blocks are sorted
 */
export type SortTieBreaker = (a: StylingBlock, b: StylingBlock) => number;

/**
 * Helper which converts from a hierachicaly styling list (generated by `_buildHierachy`) to
 * a list of React elements
 */
function _generateElements(
	text: string,
	root: HierachyNode,
	componentState: Record<string, any>,
	setComponentState: (arg: Record<string, any>) => void,
	TextWrapper: TextWrapperComponent
): React.ReactElement[] {
	let childElms: React.ReactElement[] | React.ReactElement = [];

	function makeTextElm(min: number, max: number) {
		return (
			<TextWrapper key={"__text__" + min + "-" + max + "__"} min={min} max={max} text={text}>
				{text.substring(min, max)}
			</TextWrapper>
		);
	}

	if (root.children === undefined || root.children.length === 0) {
		// Base case - if this is leaf node, simply wrap the corresponding
		// section of text in the appropriate style
		childElms = makeTextElm(root.min, root.max);
	} else {
		// Otherwise recurse down the hierachy
		let textIdx = root.min;

		for (let child of root.children) {
			if (textIdx < child.min) {
				// Then there is some extra unstyled text content before the start of the next child
				childElms.push(makeTextElm(textIdx, child.min));
			}

			childElms = childElms.concat(
				_generateElements(text, child, componentState, setComponentState, TextWrapper)
			);
			textIdx = child.max;
		}

		// Then there is some extra text content outside the styling of any children
		// of root, append it to the end
		if (textIdx < root.max) {
			childElms.push(makeTextElm(textIdx, root.max));
		}
	}

	///////////////
	// Generate props to attach to the generated element
	let props: ContentRendererProps<any, {}> = {
		styleData: root.data,
		state: {},
		setState: () => { },
	};
	if (root.id) {
		props.state = componentState[root.id];
		props.setState = (arg: React.SetStateAction<any>) => {
			setComponentState((old: Record<string, any>) => {
				let result = { ...old };
				result[root.id!] = typeof arg === 'function' ? arg(old[root.id!]) : arg;
				return result;
			});
		};
	}

	let elements = [];

	let key = `__${root.min}-${root.max}`;

	if (root.style.before && !root.isContinuation) {
		elements.push(React.createElement(
			root.style.before, { key: `${key}-b`, ...props }, []
		));
	}
	elements.push(React.createElement(
		root.style.content, { key: `${key}-c`, ...props }, childElms
	));
	if (root.style.after && root.isLast) {
		elements.push(React.createElement(
			root.style.after, { key: `${key}-a`, ...props }, []
		));
	}

	return elements;
}

interface HierachyNode extends StylingBlock {
	children?: HierachyNode[];
	isContinuation?: boolean;
	isLast?: boolean;
}

/**
 * Helper function which converts from a list of styling blocks, to an internal
 * hierhachical object representation
 */
function _buildHierachy(styling: StylingBlock[], sortTieBreaker: SortTieBreaker): HierachyNode[] {
	if (styling.length == 0) { return []; }
	if (styling.length == 1) { return [{ ...styling[0], children: [] }]; }

	// Sort into ascending order based on min field
	// If there are ties, defer to the sort tie breaker - which by default put the longest element
	// first (since this will be a parent which fully contains the subsequent blocks with same min)
	const _sorter = (a: StylingBlock, b: StylingBlock) => a.min - b.min || sortTieBreaker(a, b);
	styling.sort(_sorter);


	let result = [];

	function _recurse(root: HierachyNode, toReopen: HierachyNode[]) {
		// Consume blocks While the next one is at least partially contained
		// within this root (as opposed to being the subsequent sibling to
		// this root)
		while (styling.length && styling[0].min < root.max) {
			let next = styling.shift()!;

			root.children ||= []

			if (next.max > root.max) {
				// then the next block continues after this root
				// split the block into 2:

				// One that continues until the end of this root
				// (which we recurse into)
				root.children.push(_recurse({ ...next, max: root.max, children: [] }, []));

				// and another which starts just after this root
				toReopen.push({ ...next, min: root.max, isContinuation: true, children: [] });
			} else {
				// then the next block ends before the current root, so treat it
				// as if it were a new root
				root.children.push(_recurse({ ...next, children: [], isLast: true }, []));
			}
		}

		// we've reached the end of this root, so append the toReopen blocks to styling
		styling = toReopen.concat(styling);
		styling.sort(_sorter);

		return root;
	}

	while (styling.length) {
		let root = styling.shift()!
		result.push(root);
		_recurse(root, []);
	}

	return result;
}

function _generateDefaultComponentState(styling: StylingBlock[], oldState: Record<string, any> = {}) {
	let result = { ...oldState };

	for (let block of styling) {
		if (block.id === undefined || result[block.id] !== undefined) {
			continue;
		}
		result[block.id] = block.style.initialState === undefined ? {} : { ...block.style.initialState };
	}

	return result;
}

export interface OverlappingMarkupProps {
	/** The full plain text string to be rendered with applied styling */
	text: string;

	/**
	 * Set of style blocks to apply to the text with min/max char offsets representing the extent of the text
	 * each block is applied to
	 **/
	styling: StylingBlock[];

	/**
	 * Function called to break ties when sorting the styling elements into order
	 *
	 * This can be used to control the nesting order of overlapping styling, IE:
	 * - `<a><b> text content </b></a>`
	 * - `<b><a> text content </a></b>`
	 *
	 * Note that this function automatically sorts elements with a lower min before a higher min.
	 * This function is only called when two styling blocks have an equal min. By default we sort the
	 * blocks so the LONGER is first, therefore rendering: `<a><b> text </b> content </a>`
	 *
	 * If this is undesired, a different tie breaking algorithm can be used, which could be example
	 * produce: <b><a> text </a></b><a> content </a>
	 *
	 * This is useful when there are requirements for a particular type of styling block to always
	 * appear inside some other (eg, inline elements inside block elements), even if this means we
	 * need to generate more tags to achieve this result
	 **/
	sortTieBreaker?: (a: StylingBlock, b: StylingBlock) => number;

	/**
	 * Element type used to wrap inner most plain text - defaults to React.Fragment
	 *
	 * Will be passed following props:
	 * - children: string - the text to render
	 * - text: string     - full plain text being rendered
	 * - min: number      - first character index of `text` to be rendered
	 * - max: number      - max character index of `text` to be rendered
	 **/
	TextWrapper?: TextWrapperComponent;
}

/**
 * Main overlapping markup rendering component
 */
export const OverlappingMarkup: (
	React.FC<OverlappingMarkupProps> & {
		defaultTieBreaker: SortTieBreaker;
	}
) = ({
	text,
	styling,
	sortTieBreaker = defaultTieBreaker,
	TextWrapper = React.Fragment,
}) => {
		// Maps from block ids to the state for that block
		let [componentState, setComponentState] = React.useState<Record<string, any>>({});

		let hierachy = React.useMemo(() => {
			setComponentState(x => _generateDefaultComponentState(styling, x));

			// Our internal functions consume the styling array as we process it, but we don't want to
			// consume the actual array being used as a prop, or on subsequent re-renders there will be
			// no styling - so we pass a copy into _buildHierachy
			return _buildHierachy([...styling], sortTieBreaker);
		}, [styling, sortTieBreaker]);

		const elements = React.useMemo(() => {
			let root = {
				min: 0,
				max: text.length,
				style: { content: (props: any) => (<>{props.children}</>) },
				children: hierachy,
			};

			return _generateElements(text, root, componentState, setComponentState, TextWrapper);
		}, [text, componentState, hierachy, setComponentState, TextWrapper]);

		return <>{elements}</>;
	}
OverlappingMarkup.displayName = 'OverlappingMarkup';
OverlappingMarkup.defaultTieBreaker = defaultTieBreaker;

/**
 * Default sort order tie breaker which puts nests shorter styling blocks inside longer blocks
 */
export function defaultTieBreaker(a: StylingBlock, b: StylingBlock) {
	return b.max - a.max;
}

export { OverlappingMarkup as default };